# Задача 9: Оптимизированная сортировка слиянием и сравнение с другими методами сортировки

## Описание

Данная задача включает реализацию алгоритма сортировки слиянием с оптимизацией, позволяющей избегать объединения уже отсортированных подмассивов. Кроме того, реализованы методы сортировки вставками и выбором для сравнения производительности. Основная цель — определить пороговый размер массива, при котором сортировка слиянием начинает работать быстрее, чем сортировки вставками и выбора.

## Структура проекта

```
Task-9/
|-- src/
|   |-- __init__.py
|   |-- merge_sort_optimized.py
|   |-- input.txt
|   |-- output.txt
|-- tests/
|   |-- __init__.py
|   |-- test_sorting_algorithms.py
|-- README.md
```

### Описание файлов:

- **src/merge_sort_optimized.py**: Основной скрипт с реализацией оптимизированной сортировки слиянием, а также сортировок вставками и выбором. Содержит функции для измерения времени выполнения и определения порогового размера массива.
- **src/input.txt**: Входной файл, содержащий массив чисел для сортировки (используется при необходимости).
- **src/output.txt**: Выходной файл, содержащий отсортированный массив или результаты сравнения сортировок.
- **tests/test_sorting_algorithms.py**: Модуль с тестами для проверки корректности работы всех реализованных алгоритмов сортировки.

## Как запустить проект

1. **Установка зависимостей**: Проект не требует дополнительных зависимостей, кроме стандартной библиотеки Python.

2. **Запуск алгоритмов сортировки и сравнения производительности**:

   - Перейдите в директорию `Task-9/src`.
   - Убедитесь, что файл `input.txt` содержит корректные входные данные (если используется).
   - Выполните команду:
     ```sh
     python merge_sort_optimized.py
     ```
   - Результаты сортировки или сравнения производительности будут записаны в файл `output.txt` или выведены в консоль.

3. **Запуск тестов**:

   - Перейдите в директорию `Task-9/tests`.
   - Выполните команду:
     ```sh
     python -m unittest test_sorting_algorithms.py
     ```
   - Все тесты должны завершиться успешно, подтверждая корректность работы алгоритмов сортировки.

## Формат входных и выходных данных

- **Входной файл (`input.txt`)**:

  - Содержит массив целых чисел, разделенных пробелами или переносами строк.
  
  Пример:
  ```
  12 52 0 7 9 1
  ```

- **Выходной файл (`output.txt`)**:

  - Содержит отсортированный массив чисел или результаты сравнения времени выполнения различных алгоритмов сортировки.
  
  Пример отсортированного массива:
  ```
  0 1 7 9 12 52
  ```
  
  Пример результатов сравнения:
  ```
  Размер: 43 | Merge Sort: 0.000234s | Insertion Sort: 0.000292s | Selection Sort: 0.000338s
  Merge Sort быстрее, чем Insertion Sort и Selection Sort при размере массива: 43
  ```

## Описание алгоритма

### Оптимизированная сортировка слиянием

Реализована сортировка слиянием с оптимизацией: перед объединением двух подмассивов проверяется, уже ли они отсортированы. Если последний элемент левого подмассива меньше или равен первому элементу правого подмассива, объединение выполняется простым конкатенированием, что позволяет сэкономить время на ненужных операциях слияния.

### Сортировка вставками

Алгоритм сортировки вставками проходит по массиву, на каждом шаге вставляя текущий элемент в уже отсортированную часть массива. Этот метод эффективен для небольших массивов.

### Сортировка выбором

Алгоритм сортировки выбором проходит по массиву, на каждом шаге выбирая минимальный элемент из неотсортированной части и помещая его на соответствующую позицию. Этот метод имеет фиксированную производительность, независимо от исходного порядка элементов.

### Сравнение производительности

С помощью функции `measure_time` измеряется время выполнения каждой сортировки на массивах разного размера. Программа ищет пороговый размер массива, начиная с которого сортировка слиянием начинает работать быстрее, чем сортировки вставками и выборами.

## Тестирование

Для проверки работоспособности алгоритмов реализованы юнит-тесты в файле `test_sorting_algorithms.py`. Тесты включают:

- **Стандартные случаи**:
  - Сортировка пустого массива.
  - Сортировка массива из одного элемента.
  - Сортировка уже отсортированного массива.
  - Сортировка массива, отсортированного в обратном порядке.
  - Сортировка случайного массива.
  - Сортировка массива с дубликатами.

- **Ошибочные случаи**:
  - Передача некорректных аргументов (не список или `None`), что должно вызывать исключение `TypeError`.

- **Крайние случаи**:
  - Массивы с минимальным и максимальным количеством элементов.

Запуск тестов позволяет убедиться в корректности работы функций сортировки для различных сценариев.

## Примеры

### Пример 1: Сортировка массива

**Входной файл (`input.txt`):**
```
12 52 0 7 9 1
```

**Запуск программы:**
```sh
python merge_sort_optimized.py
```

**Выходной файл (`output.txt`):**
```
0 1 7 9 12 52
```

### Пример 2: Сравнение производительности сортировок

**Запуск программы:**
```sh
python merge_sort_optimized.py
```

**Пример вывода в консоль:**
```
Размер: 1 | Merge Sort: 0.000005s | Insertion Sort: 0.000003s | Selection Sort: 0.000002s
Размер: 2 | Merge Sort: 0.000007s | Insertion Sort: 0.000004s | Selection Sort: 0.000004s
Размер: 3 | Merge Sort: 0.000009s | Insertion Sort: 0.000005s | Selection Sort: 0.000006s
...
Размер: 43 | Merge Sort: 0.000234s | Insertion Sort: 0.000292s | Selection Sort: 0.000338s
Merge Sort быстрее, чем Insertion Sort и Selection Sort при размере массива: 43
```

В данном примере видно, что при размере массива 43 сортировка слиянием начинает работать быстрее, чем сортировки вставками и выборами.

## Примечание

Обратите внимание, что пороговый размер может варьироваться в зависимости от производительности вашей системы и конкретной реализации сортировок. Рекомендуется запускать программу несколько раз для более точного определения порога.

## Запуск программы

Для запуска основной программы используйте команду:

```bash
python merge_sort_optimized.py
```

Для запуска тестов используйте:

```bash
python -m unittest test_sorting_algorithms.py
```

## Вывод

Данная реализация позволяет эффективно использовать сортировку слиянием на больших массивах, избегая лишних операций слияния на уже отсортированных подмассивах. Сравнение с сортировками вставками и выборами помогает определить оптимальный метод сортировки в зависимости от размера массива, что может быть полезно при разработке высокопроизводительных приложений.