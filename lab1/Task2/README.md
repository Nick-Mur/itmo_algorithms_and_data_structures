# Задача 2: Сортировка вставками с отслеживанием индексов перемещения

## Описание

В данной задаче реализуется алгоритм сортировки вставками с отслеживанием индексов перемещения элементов. Алгоритм не только сортирует массив, но и возвращает индексы конечных позиций элементов, чтобы лучше понять, как происходят перемещения элементов в процессе сортировки.

### Формат входных данных
- Входные данные находятся в файле `input.txt`.
- Первая строка содержит одно число `n` (1 ≤ n ≤ 1000) — количество элементов в массиве.
- Вторая строка содержит `n` целых чисел, по модулю не превосходящих 10^9.

### Формат выходных данных
- В выходном файле `output.txt` должны содержаться две строки:
  1. Первая строка — индексы конечных позиций элементов после сортировки.
  2. Вторая строка — отсортированный массив. Все числа должны быть разделены ровно одним пробелом.

### Ограничения
- Время выполнения: 2 секунды.
- Память: 256 МБ.

## Структура проекта

```
Task-2/
|-- src/
|   |-- input.txt                    # Входные данные
|   |-- insertion_sort_with_indexes.py # Реализация алгоритма сортировки вставками с отслеживанием индексов
|   |-- output.txt                   # Выходные данные
|-- tests/
|   |-- test_insertion_sort_with_indexes.py  # Тесты для проверки корректности работы алгоритма
```

## Код задачи

```python
def insertion_sort(list_arr):
    """
    Функция сортировки вставками, которая отслеживает перемещения элементов.
    Возвращает индексы конечных позиций элементов и отсортированный массив.

    :param list_arr: Список целых чисел для сортировки.
    :return: Список индексов конечных позиций и отсортированный список.
    """
    index_result = [1]  # Начинаем с первого индекса, так как первый элемент уже на месте
    for i in range(1, len(list_arr)):
        for j in range(i - 1, -1, -1):
            if list_arr[i] < list_arr[j]:
                # Меняем местами элементы и обновляем их позиции
                list_arr[i], list_arr[j] = list_arr[j], list_arr[i]
                i, j = j, i
        index_result.append(i + 1)  # Добавляем индекс, начиная с 1
    return index_result, list_arr

if __name__ == '__main__':
    with open('input.txt') as f:
        n, massive = f.readlines()
    indexes, array = insertion_sort(list(map(int, massive.split())))
    with open('output.txt', 'w') as f:
        print(' '.join(list(map(str, indexes))), file=f)
        print(' '.join(list(map(str, array))), file=f
```

## Запуск проекта

1. Перейдите в директорию `src`.
2. Убедитесь, что файл `input.txt` содержит корректные входные данные в указанном формате.
3. Запустите скрипт:
   ```sh
   python insertion_sort_with_indexes.py
   ```
4. Результат выполнения будет записан в файл `output.txt`.

## Тестирование

Для проверки корректности работы программы выполните тесты, находящиеся в директории `tests`.

1. Перейдите в директорию `tests`.
2. Выполните команду:
   ```sh
   python -m unittest test_insertion_sort_with_indexes.py
   ```

### Тесты

```python
import unittest
import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../src')))
from insertion_sort_with_indexes import insertion_sort

class TestInsertionSort(unittest.TestCase):
    """
    Тесты для функции сортировки вставками.
    """

    def test_insertion_sort(self):
        """
        Проверка корректности работы сортировки вставками.
        """
        sorted_indexes, sorted_arr = insertion_sort([1, 8, 4, 2, 3, 7, 5, 6, 9, 0])
        self.assertEqual(sorted_arr, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
        self.assertEqual(sorted_indexes, [1, 2, 2, 2, 3, 5, 5, 6, 9, 1])

if __name__ == '__main__':
    unittest.main()
```

## Пример

### Входные данные (input.txt)
```
10
1 8 4 2 3 7 5 6 9 0
```

### Выходные данные (output.txt)
```
1 2 2 2 3 5 5 6 9 1
0 1 2 3 4 5 6 7 8 9
```
